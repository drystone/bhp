#!/usr/bin/python

# Copyright 2010,2012 John Hedges
#
# This file is part of bhp.
#
# bhp is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# bhp is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# bhp. If not, see <http://www.gnu.org/licenses/>.

import argparse, os, sys, serial, socket


class UdinException(Exception):
    pass

class Udin:
    def __init__(self, device_path):
        self._tty = serial.Serial(device_path, timeout=1)

    def switch(self, device, state):
        """device 1-8, state 'on' or 'off'"""
        if state == 'on':
            self._send_command('n' + device)
        else:
            self._send_command('f' + device)

    def get_state(self):
        self._send_command('s0')
        return self._recv()

    def set_state(self, state):
        self._send_command('r' + str(state))

    def _send_command(self, command, attempts=3):
        self._tty.write(command + '\r')
        echo = self._recv()
        if echo != command:
            self._tty.flushOutput()
            self._tty.flushInput()
            if --attempts:
                self._send_command(command, attempts)
            else:
                raise UdinException()
            
    def _recv(self):
        return self._tty.readline()[:-2]

    def close(self):
        self._tty.close()

parser = argparse.ArgumentParser(description='UDIN server')
parser.add_argument('-a', '--address', default='/tmp/udind', help='address of unix domain socket to create (defaults to /tmp/udind)')
parser.add_argument('-d', '--device', default='/dev/ttyUSB0', help='sepcify UDIN device (defaults to /dev/ttyUSB0)')
args = parser.parse_args()

udin = Udin(args.device)

try: os.unlink(args.address)
except: pass
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.bind(args.address)
sock.listen(1)
while True:
    conn, addr = sock.accept()
    while True:
        data = conn.recv(1024)
        if not data: break
        for command in data.split('\n'):
            if not command: continue
            tokens = command.split()
            if tokens[0] == 'reset':
                udin.set_state(tokens[1])
            elif tokens[0] == 'switch':
                udin.switch(tokens[1], tokens[2])
            elif tokens[0] == 'status':
                conn.sendall(udin.get_state())
    conn.close()


